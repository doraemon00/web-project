{"remainingRequest":"E:\\前端学习\\2020-bloom\\web-project\\5.性能优化\\5-3.优化loader性能\\node_modules\\_babel-loader@8.2.2@babel-loader\\lib\\index.js!E:\\前端学习\\2020-bloom\\web-project\\5.性能优化\\5-3.优化loader性能\\node_modules\\_source-map@0.7.3@source-map\\lib\\binary-search.js","dependencies":[{"path":"E:\\前端学习\\2020-bloom\\web-project\\5.性能优化\\5-3.优化loader性能\\node_modules\\_source-map@0.7.3@source-map\\lib\\binary-search.js","mtime":1526491281000},{"path":"E:\\前端学习\\2020-bloom\\web-project\\5.性能优化\\5-3.优化loader性能\\node_modules\\_cache-loader@4.1.0@cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\前端学习\\2020-bloom\\web-project\\5.性能优化\\5-3.优化loader性能\\node_modules\\_babel-loader@8.2.2@babel-loader\\lib\\index.js","mtime":315532800000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqLwoKLyoKICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnMKICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6CiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2UKICovCmV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxOwpleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EID0gMjsKLyoqCiAqIFJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoLgogKgogKiBAcGFyYW0gYUxvdyBJbmRpY2VzIGhlcmUgYW5kIGxvd2VyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuCiAqIEBwYXJhbSBhSGlnaCBJbmRpY2VzIGhlcmUgYW5kIGhpZ2hlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLgogKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuCiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIG5vbi1lbXB0eSBhcnJheSBiZWluZyBzZWFyY2hlZC4KICogQHBhcmFtIGFDb21wYXJlIEZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byBlbGVtZW50cyBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMS4KICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvcgogKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGUKICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmUKICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLgogKi8KCmZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHsKICAvLyBUaGlzIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgd2hlbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlOgogIC8vCiAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci4KICAvLwogIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2YKICAvLyAgICAgIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudC4KICAvLwogIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0CiAgLy8gICAgICBlbGVtZW50IHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2UgcmV0dXJuIC0xLgogIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7CiAgY29uc3QgY21wID0gYUNvbXBhcmUoYU5lZWRsZSwgYUhheXN0YWNrW21pZF0sIHRydWUpOwoKICBpZiAoY21wID09PSAwKSB7CiAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuCiAgICByZXR1cm4gbWlkOwogIH0gZWxzZSBpZiAoY21wID4gMCkgewogICAgLy8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uCiAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7CiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSB1cHBlciBoYWxmLgogICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTsKICAgIH0gLy8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmCiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLgoKCiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkgewogICAgICByZXR1cm4gYUhpZ2ggPCBhSGF5c3RhY2subGVuZ3RoID8gYUhpZ2ggOiAtMTsKICAgIH0KCiAgICByZXR1cm4gbWlkOwogIH0gLy8gT3VyIG5lZWRsZSBpcyBsZXNzIHRoYW4gYUhheXN0YWNrW21pZF0uCgoKICBpZiAobWlkIC0gYUxvdyA+IDEpIHsKICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLgogICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTsKICB9IC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuCgoKICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkgewogICAgcmV0dXJuIG1pZDsKICB9CgogIHJldHVybiBhTG93IDwgMCA/IC0xIDogYUxvdzsKfQovKioKICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuCiAqIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBlbGVtZW50IGlmIHRoZXJlIGlzIG5vIGV4YWN0IGhpdC4gVGhpcyBpcyBiZWNhdXNlCiAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cywKICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnMKICogdGhhdCB5b3UgYXJlbid0IG9uIHRoZSB2ZXJ5IHN0YXJ0IG9mIGEgcmVnaW9uLgogKgogKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLgogKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBhcnJheSB0aGF0IGlzIGJlaW5nIHNlYXJjaGVkLgogKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZQogKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzCiAqICAgICB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIHRoZSBlbGVtZW50LCByZXNwZWN0aXZlbHkuCiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3IKICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlCiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlCiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC4KICogICAgIERlZmF1bHRzIHRvICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnLgogKi8KCgpleHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykgewogIGlmIChhSGF5c3RhY2subGVuZ3RoID09PSAwKSB7CiAgICByZXR1cm4gLTE7CiAgfQoKICBsZXQgaW5kZXggPSByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzIHx8IGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQpOwoKICBpZiAoaW5kZXggPCAwKSB7CiAgICByZXR1cm4gLTE7CiAgfSAvLyBXZSBoYXZlIGZvdW5kIGVpdGhlciB0aGUgZXhhY3QgZWxlbWVudCwgb3IgdGhlIG5leHQtY2xvc2VzdCBlbGVtZW50IHRoYW4KICAvLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoCiAgLy8gZWxlbWVudC4gTWFrZSBzdXJlIHdlIGFsd2F5cyByZXR1cm4gdGhlIHNtYWxsZXN0IG9mIHRoZXNlLgoKCiAgd2hpbGUgKGluZGV4IC0gMSA+PSAwKSB7CiAgICBpZiAoYUNvbXBhcmUoYUhheXN0YWNrW2luZGV4XSwgYUhheXN0YWNrW2luZGV4IC0gMV0sIHRydWUpICE9PSAwKSB7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIC0taW5kZXg7CiAgfQoKICByZXR1cm4gaW5kZXg7Cn07"},{"version":3,"sources":["E:/前端学习/2020-bloom/web-project/5.性能优化/5-3.优化loader性能/node_modules/_source-map@0.7.3@source-map/lib/binary-search.js"],"names":["exports","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","recursiveSearch","aLow","aHigh","aNeedle","aHaystack","aCompare","aBias","mid","Math","floor","cmp","length","search","index"],"mappings":"AAAA;;AACA;AACA;AACA;AACA;AACA;AAEAA,OAAO,CAACC,oBAAR,GAA+B,CAA/B;AACAD,OAAO,CAACE,iBAAR,GAA4B,CAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,eAAT,CAAyBC,IAAzB,EAA+BC,KAA/B,EAAsCC,OAAtC,EAA+CC,SAA/C,EAA0DC,QAA1D,EAAoEC,KAApE,EAA2E;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAMC,GAAG,GAAGC,IAAI,CAACC,KAAL,CAAW,CAACP,KAAK,GAAGD,IAAT,IAAiB,CAA5B,IAAiCA,IAA7C;AACA,QAAMS,GAAG,GAAGL,QAAQ,CAACF,OAAD,EAAUC,SAAS,CAACG,GAAD,CAAnB,EAA0B,IAA1B,CAApB;;AACA,MAAIG,GAAG,KAAK,CAAZ,EAAe;AACb;AACA,WAAOH,GAAP;AACD,GAHD,MAGO,IAAIG,GAAG,GAAG,CAAV,EAAa;AAClB;AACA,QAAIR,KAAK,GAAGK,GAAR,GAAc,CAAlB,EAAqB;AACnB;AACA,aAAOP,eAAe,CAACO,GAAD,EAAML,KAAN,EAAaC,OAAb,EAAsBC,SAAtB,EAAiCC,QAAjC,EAA2CC,KAA3C,CAAtB;AACD,KALiB,CAOlB;AACA;;;AACA,QAAIA,KAAK,IAAIT,OAAO,CAACE,iBAArB,EAAwC;AACtC,aAAOG,KAAK,GAAGE,SAAS,CAACO,MAAlB,GAA2BT,KAA3B,GAAmC,CAAC,CAA3C;AACD;;AACD,WAAOK,GAAP;AACD,GA5BwE,CA8BzE;;;AACA,MAAIA,GAAG,GAAGN,IAAN,GAAa,CAAjB,EAAoB;AAClB;AACA,WAAOD,eAAe,CAACC,IAAD,EAAOM,GAAP,EAAYJ,OAAZ,EAAqBC,SAArB,EAAgCC,QAAhC,EAA0CC,KAA1C,CAAtB;AACD,GAlCwE,CAoCzE;;;AACA,MAAIA,KAAK,IAAIT,OAAO,CAACE,iBAArB,EAAwC;AACtC,WAAOQ,GAAP;AACD;;AACD,SAAON,IAAI,GAAG,CAAP,GAAW,CAAC,CAAZ,GAAgBA,IAAvB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAJ,OAAO,CAACe,MAAR,GAAiB,SAASA,MAAT,CAAgBT,OAAhB,EAAyBC,SAAzB,EAAoCC,QAApC,EAA8CC,KAA9C,EAAqD;AACpE,MAAIF,SAAS,CAACO,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,WAAO,CAAC,CAAR;AACD;;AAED,MAAIE,KAAK,GAAGb,eAAe,CAAC,CAAC,CAAF,EAAKI,SAAS,CAACO,MAAf,EAAuBR,OAAvB,EAAgCC,SAAhC,EACCC,QADD,EACWC,KAAK,IAAIT,OAAO,CAACC,oBAD5B,CAA3B;;AAEA,MAAIe,KAAK,GAAG,CAAZ,EAAe;AACb,WAAO,CAAC,CAAR;AACD,GATmE,CAWpE;AACA;AACA;;;AACA,SAAOA,KAAK,GAAG,CAAR,IAAa,CAApB,EAAuB;AACrB,QAAIR,QAAQ,CAACD,SAAS,CAACS,KAAD,CAAV,EAAmBT,SAAS,CAACS,KAAK,GAAG,CAAT,CAA5B,EAAyC,IAAzC,CAAR,KAA2D,CAA/D,EAAkE;AAChE;AACD;;AACD,MAAEA,KAAF;AACD;;AAED,SAAOA,KAAP;AACD,CAtBD","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  const mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  const cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  } else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    }\n    return mid;\n  }\n\n  // Our needle is less than aHaystack[mid].\n  if (mid - aLow > 1) {\n    // The element is in the lower half.\n    return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n  }\n\n  // we are in termination case (3) or (2) and return the appropriate thing.\n  if (aBias == exports.LEAST_UPPER_BOUND) {\n    return mid;\n  }\n  return aLow < 0 ? -1 : aLow;\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  let index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n"]}]}