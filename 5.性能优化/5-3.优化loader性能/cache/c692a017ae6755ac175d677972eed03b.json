{"remainingRequest":"E:\\前端学习\\2020-bloom\\web-project\\5.性能优化\\5-3.优化loader性能\\node_modules\\_babel-loader@8.2.2@babel-loader\\lib\\index.js!E:\\前端学习\\2020-bloom\\web-project\\5.性能优化\\5-3.优化loader性能\\node_modules\\_source-map@0.7.3@source-map\\lib\\source-map-consumer.js","dependencies":[{"path":"E:\\前端学习\\2020-bloom\\web-project\\5.性能优化\\5-3.优化loader性能\\node_modules\\_source-map@0.7.3@source-map\\lib\\source-map-consumer.js","mtime":1526491281000},{"path":"E:\\前端学习\\2020-bloom\\web-project\\5.性能优化\\5-3.优化loader性能\\node_modules\\_cache-loader@4.1.0@cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\前端学习\\2020-bloom\\web-project\\5.性能优化\\5-3.优化loader性能\\node_modules\\_babel-loader@8.2.2@babel-loader\\lib\\index.js","mtime":315532800000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqLwoKLyoKICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnMKICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6CiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2UKICovCmNvbnN0IHV0aWwgPSByZXF1aXJlKCIuL3V0aWwiKTsKCmNvbnN0IGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoIi4vYmluYXJ5LXNlYXJjaCIpOwoKY29uc3QgQXJyYXlTZXQgPSByZXF1aXJlKCIuL2FycmF5LXNldCIpLkFycmF5U2V0OwoKY29uc3QgYmFzZTY0VkxRID0gcmVxdWlyZSgiLi9iYXNlNjQtdmxxIik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnMKCgpjb25zdCByZWFkV2FzbSA9IHJlcXVpcmUoIi4uL2xpYi9yZWFkLXdhc20iKTsKCmNvbnN0IHdhc20gPSByZXF1aXJlKCIuL3dhc20iKTsKCmNvbnN0IElOVEVSTkFMID0gU3ltYm9sKCJzbWNJbnRlcm5hbCIpOwoKY2xhc3MgU291cmNlTWFwQ29uc3VtZXIgewogIGNvbnN0cnVjdG9yKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHsKICAgIC8vIElmIHRoZSBjb25zdHJ1Y3RvciB3YXMgY2FsbGVkIGJ5IHN1cGVyKCksIGp1c3QgcmV0dXJuIFByb21pc2U8dGhpcz4uCiAgICAvLyBZZXMsIHRoaXMgaXMgYSBoYWNrIHRvIHJldGFpbiB0aGUgcHJlLWV4aXN0aW5nIEFQSSBvZiB0aGUgYmFzZS1jbGFzcwogICAgLy8gY29uc3RydWN0b3IgYWxzbyBiZWluZyBhbiBhc3luYyBmYWN0b3J5IGZ1bmN0aW9uLgogICAgaWYgKGFTb3VyY2VNYXAgPT0gSU5URVJOQUwpIHsKICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTsKICAgIH0KCiAgICByZXR1cm4gX2ZhY3RvcnkoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCk7CiAgfQoKICBzdGF0aWMgaW5pdGlhbGl6ZShvcHRzKSB7CiAgICByZWFkV2FzbS5pbml0aWFsaXplKG9wdHNbImxpYi9tYXBwaW5ncy53YXNtIl0pOwogIH0KCiAgc3RhdGljIGZyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkgewogICAgcmV0dXJuIF9mYWN0b3J5QlNNKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpOwogIH0KICAvKioKICAgKiBDb25zdHJ1Y3QgYSBuZXcgYFNvdXJjZU1hcENvbnN1bWVyYCBmcm9tIGByYXdTb3VyY2VNYXBgIGFuZCBgc291cmNlTWFwVXJsYAogICAqIChzZWUgdGhlIGBTb3VyY2VNYXBDb25zdW1lcmAgY29uc3RydWN0b3IgZm9yIGRldGFpbHMuIFRoZW4sIGludm9rZSB0aGUgYGFzeW5jCiAgICogZnVuY3Rpb24gZihTb3VyY2VNYXBDb25zdW1lcikgLT4gVGAgd2l0aCB0aGUgbmV3bHkgY29uc3RydWN0ZWQgY29uc3VtZXIsIHdhaXQKICAgKiBmb3IgYGZgIHRvIGNvbXBsZXRlLCBjYWxsIGBkZXN0cm95YCBvbiB0aGUgY29uc3VtZXIsIGFuZCByZXR1cm4gYGZgJ3MgcmV0dXJuCiAgICogdmFsdWUuCiAgICoKICAgKiBZb3UgbXVzdCBub3QgdXNlIHRoZSBjb25zdW1lciBhZnRlciBgZmAgY29tcGxldGVzIQogICAqCiAgICogQnkgdXNpbmcgYHdpdGhgLCB5b3UgZG8gbm90IGhhdmUgdG8gcmVtZW1iZXIgdG8gbWFudWFsbHkgY2FsbCBgZGVzdHJveWAgb24KICAgKiB0aGUgY29uc3VtZXIsIHNpbmNlIGl0IHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgb25jZSBgZmAgY29tcGxldGVzLgogICAqCiAgICogYGBganMKICAgKiBjb25zdCB4U3F1YXJlZCA9IGF3YWl0IFNvdXJjZU1hcENvbnN1bWVyLndpdGgoCiAgICogICBteVJhd1NvdXJjZU1hcCwKICAgKiAgIG51bGwsCiAgICogICBhc3luYyBmdW5jdGlvbiAoY29uc3VtZXIpIHsKICAgKiAgICAgLy8gVXNlIGBjb25zdW1lcmAgaW5zaWRlIGhlcmUgYW5kIGRvbid0IHdvcnJ5IGFib3V0IHJlbWVtYmVyaW5nCiAgICogICAgIC8vIHRvIGNhbGwgYGRlc3Ryb3lgLgogICAqCiAgICogICAgIGNvbnN0IHggPSBhd2FpdCB3aGF0ZXZlcihjb25zdW1lcik7CiAgICogICAgIHJldHVybiB4ICogeDsKICAgKiAgIH0KICAgKiApOwogICAqCiAgICogLy8gWW91IG1heSBub3QgdXNlIHRoYXQgYGNvbnN1bWVyYCBhbnltb3JlIG91dCBoZXJlOyBpdCBoYXMKICAgKiAvLyBiZWVuIGRlc3Ryb3llZC4gQnV0IHlvdSBjYW4gdXNlIGB4U3F1YXJlZGAuCiAgICogY29uc29sZS5sb2coeFNxdWFyZWQpOwogICAqIGBgYAogICAqLwoKCiAgc3RhdGljIHdpdGgocmF3U291cmNlTWFwLCBzb3VyY2VNYXBVcmwsIGYpIHsKICAgIC8vIE5vdGU6IFRoZSBgYWNvcm5gIHZlcnNpb24gdGhhdCBgd2VicGFja2AgY3VycmVudGx5IGRlcGVuZHMgb24gZG9lc24ndAogICAgLy8gc3VwcG9ydCBgYXN5bmNgIGZ1bmN0aW9ucywgYW5kIHRoZSBub2RlcyB0aGF0IHdlIHN1cHBvcnQgZG9uJ3QgYWxsIGhhdmUKICAgIC8vIGAuZmluYWxseWAuIFRoZXJlZm9yZSwgdGhpcyBpcyB3cml0dGVuIGEgYml0IG1vcmUgY29udm9sdXRlZGx5IHRoYW4gaXQKICAgIC8vIHNob3VsZCByZWFsbHkgYmUuCiAgICBsZXQgY29uc3VtZXIgPSBudWxsOwogICAgY29uc3QgcHJvbWlzZSA9IG5ldyBTb3VyY2VNYXBDb25zdW1lcihyYXdTb3VyY2VNYXAsIHNvdXJjZU1hcFVybCk7CiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGMgPT4gewogICAgICBjb25zdW1lciA9IGM7CiAgICAgIHJldHVybiBmKGMpOwogICAgfSkudGhlbih4ID0+IHsKICAgICAgaWYgKGNvbnN1bWVyKSB7CiAgICAgICAgY29uc3VtZXIuZGVzdHJveSgpOwogICAgICB9CgogICAgICByZXR1cm4geDsKICAgIH0sIGUgPT4gewogICAgICBpZiAoY29uc3VtZXIpIHsKICAgICAgICBjb25zdW1lci5kZXN0cm95KCk7CiAgICAgIH0KCiAgICAgIHRocm93IGU7CiAgICB9KTsKICB9CiAgLyoqCiAgICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseQogICAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZAogICAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuCiAgICovCgoKICBfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkgewogICAgdGhyb3cgbmV3IEVycm9yKCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzIik7CiAgfQogIC8qKgogICAqIEl0ZXJhdGUgb3ZlciBlYWNoIG1hcHBpbmcgYmV0d2VlbiBhbiBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4gYW5kIGEKICAgKiBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gaW4gdGhpcyBzb3VyY2UgbWFwLgogICAqCiAgICogQHBhcmFtIEZ1bmN0aW9uIGFDYWxsYmFjawogICAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIG1hcHBpbmcuCiAgICogQHBhcmFtIE9iamVjdCBhQ29udGV4dAogICAqICAgICAgICBPcHRpb25hbC4gSWYgc3BlY2lmaWVkLCB0aGlzIG9iamVjdCB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBgdGhpc2AgZXZlcnkKICAgKiAgICAgICAgdGltZSB0aGF0IGBhQ2FsbGJhY2tgIGlzIGNhbGxlZC4KICAgKiBAcGFyYW0gYU9yZGVyCiAgICogICAgICAgIEVpdGhlciBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYCBvcgogICAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVJgLiBTcGVjaWZpZXMgd2hldGhlciB5b3Ugd2FudCB0bwogICAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtbgogICAqICAgICAgICBvcmRlciBvciB0aGUgb3JpZ2luYWwncyBzb3VyY2UvbGluZS9jb2x1bW4gb3JkZXIsIHJlc3BlY3RpdmVseS4gRGVmYXVsdHMgdG8KICAgKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAuCiAgICovCgoKICBlYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHsKICAgIHRocm93IG5ldyBFcnJvcigiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBlYWNoTWFwcGluZyIpOwogIH0KICAvKioKICAgKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLAogICAqIGxpbmUsIGFuZCBjb2x1bW4gcHJvdmlkZWQuIElmIG5vIGNvbHVtbiBpcyBwcm92aWRlZCwgcmV0dXJucyBhbGwgbWFwcGluZ3MKICAgKiBjb3JyZXNwb25kaW5nIHRvIGEgZWl0aGVyIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yIG9yIHRoZSBuZXh0CiAgICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5ncwogICAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgYW5kIGVpdGhlciB0aGUgY29sdW1uIHdlIGFyZSBzZWFyY2hpbmcgZm9yCiAgICogb3IgdGhlIG5leHQgY2xvc2VzdCBjb2x1bW4gdGhhdCBoYXMgYW55IG9mZnNldHMuCiAgICoKICAgKiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6CiAgICoKICAgKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS4KICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXIgaXMgMS1iYXNlZC4KICAgKiAgIC0gY29sdW1uOiBPcHRpb25hbC4gdGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4KICAgKiAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLgogICAqCiAgICogYW5kIGFuIGFycmF5IG9mIG9iamVjdHMgaXMgcmV0dXJuZWQsIGVhY2ggd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6CiAgICoKICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlCiAgICogICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC4KICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4KICAgKiAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLgogICAqLwoKCiAgYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoIlN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yIik7CiAgfQoKICBkZXN0cm95KCkgewogICAgdGhyb3cgbmV3IEVycm9yKCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IGRlc3Ryb3kiKTsKICB9Cgp9Ci8qKgogKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuCiAqLwoKClNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7ClNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUiA9IDE7ClNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjsKU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxOwpTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7CmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjsKLyoqCiAqIEEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2ggd2UgY2FuCiAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZQogKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4KICoKICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvcgogKiBhbHJlYWR5IHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHNvdXJjZSBtYXBzIGhhdmUgdGhlCiAqIGZvbGxvd2luZyBhdHRyaWJ1dGVzOgogKgogKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy4KICogICAtIHNvdXJjZXM6IEFuIGFycmF5IG9mIFVSTHMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy4KICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBieSBpbmRpdmlkdWFsIG1hcHBpbmdzLgogKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS4KICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy4KICogICAtIG1hcHBpbmdzOiBBIHN0cmluZyBvZiBiYXNlNjQgVkxRcyB3aGljaCBjb250YWluIHRoZSBhY3R1YWwgbWFwcGluZ3MuCiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguCiAqCiAqIEhlcmUgaXMgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF06CiAqCiAqICAgICB7CiAqICAgICAgIHZlcnNpb24gOiAzLAogKiAgICAgICBmaWxlOiAib3V0LmpzIiwKICogICAgICAgc291cmNlUm9vdCA6ICIiLAogKiAgICAgICBzb3VyY2VzOiBbImZvby5qcyIsICJiYXIuanMiXSwKICogICAgICAgbmFtZXM6IFsic3JjIiwgIm1hcHMiLCAiYXJlIiwgImZ1biJdLAogKiAgICAgICBtYXBwaW5nczogIkFBLEFCOztBQkNERTsiCiAqICAgICB9CiAqCiAqIFRoZSBzZWNvbmQgcGFyYW1ldGVyLCBpZiBnaXZlbiwgaXMgYSBzdHJpbmcgd2hvc2UgdmFsdWUgaXMgdGhlIFVSTAogKiBhdCB3aGljaCB0aGUgc291cmNlIG1hcCB3YXMgZm91bmQuICBUaGlzIFVSTCBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlCiAqIHNvdXJjZXMgYXJyYXkuCiAqCiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0P3BsaT0xIwogKi8KCmNsYXNzIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgZXh0ZW5kcyBTb3VyY2VNYXBDb25zdW1lciB7CiAgY29uc3RydWN0b3IoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkgewogICAgcmV0dXJuIHN1cGVyKElOVEVSTkFMKS50aGVuKHRoYXQgPT4gewogICAgICBsZXQgc291cmNlTWFwID0gYVNvdXJjZU1hcDsKCiAgICAgIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gInN0cmluZyIpIHsKICAgICAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7CiAgICAgIH0KCiAgICAgIGNvbnN0IHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICJ2ZXJzaW9uIik7CiAgICAgIGxldCBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAic291cmNlcyIpOyAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoCiAgICAgIC8vIHJlcXVpcmVzIHRoZSBhcnJheSkgdG8gcGxheSBuaWNlIGhlcmUuCgogICAgICBjb25zdCBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgIm5hbWVzIiwgW10pOwogICAgICBsZXQgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgInNvdXJjZVJvb3QiLCBudWxsKTsKICAgICAgY29uc3Qgc291cmNlc0NvbnRlbnQgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICJzb3VyY2VzQ29udGVudCIsIG51bGwpOwogICAgICBjb25zdCBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgIm1hcHBpbmdzIik7CiAgICAgIGNvbnN0IGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICJmaWxlIiwgbnVsbCk7IC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYQogICAgICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLgoKICAgICAgaWYgKHZlcnNpb24gIT0gdGhhdC5fdmVyc2lvbikgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiVW5zdXBwb3J0ZWQgdmVyc2lvbjogIiArIHZlcnNpb24pOwogICAgICB9CgogICAgICBpZiAoc291cmNlUm9vdCkgewogICAgICAgIHNvdXJjZVJvb3QgPSB1dGlsLm5vcm1hbGl6ZShzb3VyY2VSb290KTsKICAgICAgfQoKICAgICAgc291cmNlcyA9IHNvdXJjZXMubWFwKFN0cmluZykgLy8gU29tZSBzb3VyY2UgbWFwcyBwcm9kdWNlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBsaWtlICIuL2Zvby5qcyIgaW5zdGVhZCBvZgogICAgICAvLyAiZm9vLmpzIi4gIE5vcm1hbGl6ZSB0aGVzZSBmaXJzdCBzbyB0aGF0IGZ1dHVyZSBjb21wYXJpc29ucyB3aWxsIHN1Y2NlZWQuCiAgICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC4KICAgICAgLm1hcCh1dGlsLm5vcm1hbGl6ZSkgLy8gQWx3YXlzIGVuc3VyZSB0aGF0IGFic29sdXRlIHNvdXJjZXMgYXJlIGludGVybmFsbHkgc3RvcmVkIHJlbGF0aXZlIHRvCiAgICAgIC8vIHRoZSBzb3VyY2Ugcm9vdCwgaWYgdGhlIHNvdXJjZSByb290IGlzIGFic29sdXRlLiBOb3QgZG9pbmcgdGhpcyB3b3VsZAogICAgICAvLyBiZSBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMgd2hlbiB0aGUgc291cmNlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlCiAgICAgIC8vIHNvdXJjZSAodmFsaWQsIGJ1dCB3aHk/PykuIFNlZSBnaXRodWIgaXNzdWUgIzE5OSBhbmQgYnVnemlsLmxhLzExODg5ODIuCiAgICAgIC5tYXAoZnVuY3Rpb24gKHNvdXJjZSkgewogICAgICAgIHJldHVybiBzb3VyY2VSb290ICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2VSb290KSAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlKSA/IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlKSA6IHNvdXJjZTsKICAgICAgfSk7IC8vIFBhc3MgYHRydWVgIGJlbG93IHRvIGFsbG93IGR1cGxpY2F0ZSBuYW1lcyBhbmQgc291cmNlcy4gV2hpbGUgc291cmNlIG1hcHMKICAgICAgLy8gYXJlIGludGVuZGVkIHRvIGJlIGNvbXByZXNzZWQgYW5kIGRlZHVwbGljYXRlZCwgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXIKICAgICAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZQogICAgICAvLyAjNzIgYW5kIGJ1Z3ppbC5sYS84ODk0OTIuCgogICAgICB0aGF0Ll9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcy5tYXAoU3RyaW5nKSwgdHJ1ZSk7CiAgICAgIHRoYXQuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoc291cmNlcywgdHJ1ZSk7CiAgICAgIHRoYXQuX2Fic29sdXRlU291cmNlcyA9IHRoYXQuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykgewogICAgICAgIHJldHVybiB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgcywgYVNvdXJjZU1hcFVSTCk7CiAgICAgIH0pOwogICAgICB0aGF0LnNvdXJjZVJvb3QgPSBzb3VyY2VSb290OwogICAgICB0aGF0LnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7CiAgICAgIHRoYXQuX21hcHBpbmdzID0gbWFwcGluZ3M7CiAgICAgIHRoYXQuX3NvdXJjZU1hcFVSTCA9IGFTb3VyY2VNYXBVUkw7CiAgICAgIHRoYXQuZmlsZSA9IGZpbGU7CiAgICAgIHRoYXQuX2NvbXB1dGVkQ29sdW1uU3BhbnMgPSBmYWxzZTsKICAgICAgdGhhdC5fbWFwcGluZ3NQdHIgPSAwOwogICAgICB0aGF0Ll93YXNtID0gbnVsbDsKICAgICAgcmV0dXJuIHdhc20oKS50aGVuKHcgPT4gewogICAgICAgIHRoYXQuX3dhc20gPSB3OwogICAgICAgIHJldHVybiB0aGF0OwogICAgICB9KTsKICAgIH0pOwogIH0KICAvKioKICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGluZGV4IG9mIGEgc291cmNlLiAgUmV0dXJucyAtMSBpZiBub3QKICAgKiBmb3VuZC4KICAgKi8KCgogIF9maW5kU291cmNlSW5kZXgoYVNvdXJjZSkgewogICAgbGV0IHJlbGF0aXZlU291cmNlID0gYVNvdXJjZTsKCiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHsKICAgICAgcmVsYXRpdmVTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgcmVsYXRpdmVTb3VyY2UpOwogICAgfQoKICAgIGlmICh0aGlzLl9zb3VyY2VzLmhhcyhyZWxhdGl2ZVNvdXJjZSkpIHsKICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZXMuaW5kZXhPZihyZWxhdGl2ZVNvdXJjZSk7CiAgICB9IC8vIE1heWJlIGFTb3VyY2UgaXMgYW4gYWJzb2x1dGUgVVJMIGFzIHJldHVybmVkIGJ5IHxzb3VyY2VzfC4gIEluCiAgICAvLyB0aGlzIGNhc2Ugd2UgY2FuJ3Qgc2ltcGx5IHVuZG8gdGhlIHRyYW5zZm9ybS4KCgogICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hYnNvbHV0ZVNvdXJjZXMubGVuZ3RoOyArK2kpIHsKICAgICAgaWYgKHRoaXMuX2Fic29sdXRlU291cmNlc1tpXSA9PSBhU291cmNlKSB7CiAgICAgICAgcmV0dXJuIGk7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gLTE7CiAgfQogIC8qKgogICAqIENyZWF0ZSBhIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci4KICAgKgogICAqIEBwYXJhbSBTb3VyY2VNYXBHZW5lcmF0b3IgYVNvdXJjZU1hcAogICAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuCiAgICogQHBhcmFtIFN0cmluZyBhU291cmNlTWFwVVJMCiAgICogICAgICAgIFRoZSBVUkwgYXQgd2hpY2ggdGhlIHNvdXJjZSBtYXAgY2FuIGJlIGZvdW5kIChvcHRpb25hbCkKICAgKiBAcmV0dXJucyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyCiAgICovCgoKICBzdGF0aWMgZnJvbVNvdXJjZU1hcChhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7CiAgICByZXR1cm4gbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcC50b1N0cmluZygpKTsKICB9CgogIGdldCBzb3VyY2VzKCkgewogICAgcmV0dXJuIHRoaXMuX2Fic29sdXRlU291cmNlcy5zbGljZSgpOwogIH0KCiAgX2dldE1hcHBpbmdzUHRyKCkgewogICAgaWYgKHRoaXMuX21hcHBpbmdzUHRyID09PSAwKSB7CiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7CiAgICB9CgogICAgcmV0dXJuIHRoaXMuX21hcHBpbmdzUHRyOwogIH0KICAvKioKICAgKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5CiAgICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kCiAgICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS4KICAgKi8KCgogIF9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7CiAgICBjb25zdCBzaXplID0gYVN0ci5sZW5ndGg7CgogICAgY29uc3QgbWFwcGluZ3NCdWZQdHIgPSB0aGlzLl93YXNtLmV4cG9ydHMuYWxsb2NhdGVfbWFwcGluZ3Moc2l6ZSk7CgogICAgY29uc3QgbWFwcGluZ3NCdWYgPSBuZXcgVWludDhBcnJheSh0aGlzLl93YXNtLmV4cG9ydHMubWVtb3J5LmJ1ZmZlciwgbWFwcGluZ3NCdWZQdHIsIHNpemUpOwoKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7CiAgICAgIG1hcHBpbmdzQnVmW2ldID0gYVN0ci5jaGFyQ29kZUF0KGkpOwogICAgfQoKICAgIGNvbnN0IG1hcHBpbmdzUHRyID0gdGhpcy5fd2FzbS5leHBvcnRzLnBhcnNlX21hcHBpbmdzKG1hcHBpbmdzQnVmUHRyKTsKCiAgICBpZiAoIW1hcHBpbmdzUHRyKSB7CiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fd2FzbS5leHBvcnRzLmdldF9sYXN0X2Vycm9yKCk7CgogICAgICBsZXQgbXNnID0gYEVycm9yIHBhcnNpbmcgbWFwcGluZ3MgKGNvZGUgJHtlcnJvcn0pOiBgOyAvLyBYWFg6IGtlZXAgdGhlc2UgZXJyb3IgY29kZXMgaW4gc3luYyB3aXRoIGBmaXR6Z2VuL3NvdXJjZS1tYXAtbWFwcGluZ3NgLgoKICAgICAgc3dpdGNoIChlcnJvcikgewogICAgICAgIGNhc2UgMToKICAgICAgICAgIG1zZyArPSAidGhlIG1hcHBpbmdzIGNvbnRhaW5lZCBhIG5lZ2F0aXZlIGxpbmUsIGNvbHVtbiwgc291cmNlIGluZGV4LCBvciBuYW1lIGluZGV4IjsKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlIDI6CiAgICAgICAgICBtc2cgKz0gInRoZSBtYXBwaW5ncyBjb250YWluZWQgYSBudW1iZXIgbGFyZ2VyIHRoYW4gMioqMzIiOwogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgMzoKICAgICAgICAgIG1zZyArPSAicmVhY2hlZCBFT0Ygd2hpbGUgaW4gdGhlIG1pZGRsZSBvZiBwYXJzaW5nIGEgVkxRIjsKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlIDQ6CiAgICAgICAgICBtc2cgKz0gImludmFsaWQgYmFzZSA2NCBjaGFyYWN0ZXIgd2hpbGUgcGFyc2luZyBhIFZMUSI7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgZGVmYXVsdDoKICAgICAgICAgIG1zZyArPSAidW5rbm93biBlcnJvciBjb2RlIjsKICAgICAgICAgIGJyZWFrOwogICAgICB9CgogICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTsKICAgIH0KCiAgICB0aGlzLl9tYXBwaW5nc1B0ciA9IG1hcHBpbmdzUHRyOwogIH0KCiAgZWFjaE1hcHBpbmcoYUNhbGxiYWNrLCBhQ29udGV4dCwgYU9yZGVyKSB7CiAgICBjb25zdCBjb250ZXh0ID0gYUNvbnRleHQgfHwgbnVsbDsKICAgIGNvbnN0IG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjsKICAgIGNvbnN0IHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7CgogICAgdGhpcy5fd2FzbS53aXRoTWFwcGluZ0NhbGxiYWNrKG1hcHBpbmcgPT4gewogICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT09IG51bGwpIHsKICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpOwogICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5jb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlLCB0aGlzLl9zb3VyY2VNYXBVUkwpOwoKICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9PSBudWxsKSB7CiAgICAgICAgICBtYXBwaW5nLm5hbWUgPSB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgYUNhbGxiYWNrLmNhbGwoY29udGV4dCwgbWFwcGluZyk7CiAgICB9LCAoKSA9PiB7CiAgICAgIHN3aXRjaCAob3JkZXIpIHsKICAgICAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjoKICAgICAgICAgIHRoaXMuX3dhc20uZXhwb3J0cy5ieV9nZW5lcmF0ZWRfbG9jYXRpb24odGhpcy5fZ2V0TWFwcGluZ3NQdHIoKSk7CgogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVI6CiAgICAgICAgICB0aGlzLl93YXNtLmV4cG9ydHMuYnlfb3JpZ2luYWxfbG9jYXRpb24odGhpcy5fZ2V0TWFwcGluZ3NQdHIoKSk7CgogICAgICAgICAgYnJlYWs7CgogICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLiIpOwogICAgICB9CiAgICB9KTsKICB9CgogIGFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykgewogICAgbGV0IHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAic291cmNlIik7CiAgICBjb25zdCBvcmlnaW5hbExpbmUgPSB1dGlsLmdldEFyZyhhQXJncywgImxpbmUiKTsKICAgIGNvbnN0IG9yaWdpbmFsQ29sdW1uID0gYUFyZ3MuY29sdW1uIHx8IDA7CiAgICBzb3VyY2UgPSB0aGlzLl9maW5kU291cmNlSW5kZXgoc291cmNlKTsKCiAgICBpZiAoc291cmNlIDwgMCkgewogICAgICByZXR1cm4gW107CiAgICB9CgogICAgaWYgKG9yaWdpbmFsTGluZSA8IDEpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJMaW5lIG51bWJlcnMgbXVzdCBiZSA+PSAxIik7CiAgICB9CgogICAgaWYgKG9yaWdpbmFsQ29sdW1uIDwgMCkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIkNvbHVtbiBudW1iZXJzIG11c3QgYmUgPj0gMCIpOwogICAgfQoKICAgIGNvbnN0IG1hcHBpbmdzID0gW107CgogICAgdGhpcy5fd2FzbS53aXRoTWFwcGluZ0NhbGxiYWNrKG0gPT4gewogICAgICBsZXQgbGFzdENvbHVtbiA9IG0ubGFzdEdlbmVyYXRlZENvbHVtbjsKCiAgICAgIGlmICh0aGlzLl9jb21wdXRlZENvbHVtblNwYW5zICYmIGxhc3RDb2x1bW4gPT09IG51bGwpIHsKICAgICAgICBsYXN0Q29sdW1uID0gSW5maW5pdHk7CiAgICAgIH0KCiAgICAgIG1hcHBpbmdzLnB1c2goewogICAgICAgIGxpbmU6IG0uZ2VuZXJhdGVkTGluZSwKICAgICAgICBjb2x1bW46IG0uZ2VuZXJhdGVkQ29sdW1uLAogICAgICAgIGxhc3RDb2x1bW4KICAgICAgfSk7CiAgICB9LCAoKSA9PiB7CiAgICAgIHRoaXMuX3dhc20uZXhwb3J0cy5hbGxfZ2VuZXJhdGVkX2xvY2F0aW9uc19mb3IodGhpcy5fZ2V0TWFwcGluZ3NQdHIoKSwgc291cmNlLCBvcmlnaW5hbExpbmUgLSAxLCAiY29sdW1uIiBpbiBhQXJncywgb3JpZ2luYWxDb2x1bW4pOwogICAgfSk7CgogICAgcmV0dXJuIG1hcHBpbmdzOwogIH0KCiAgZGVzdHJveSgpIHsKICAgIGlmICh0aGlzLl9tYXBwaW5nc1B0ciAhPT0gMCkgewogICAgICB0aGlzLl93YXNtLmV4cG9ydHMuZnJlZV9tYXBwaW5ncyh0aGlzLl9tYXBwaW5nc1B0cik7CgogICAgICB0aGlzLl9tYXBwaW5nc1B0ciA9IDA7CiAgICB9CiAgfQogIC8qKgogICAqIENvbXB1dGUgdGhlIGxhc3QgY29sdW1uIGZvciBlYWNoIGdlbmVyYXRlZCBtYXBwaW5nLiBUaGUgbGFzdCBjb2x1bW4gaXMKICAgKiBpbmNsdXNpdmUuCiAgICovCgoKICBjb21wdXRlQ29sdW1uU3BhbnMoKSB7CiAgICBpZiAodGhpcy5fY29tcHV0ZWRDb2x1bW5TcGFucykgewogICAgICByZXR1cm47CiAgICB9CgogICAgdGhpcy5fd2FzbS5leHBvcnRzLmNvbXB1dGVfY29sdW1uX3NwYW5zKHRoaXMuX2dldE1hcHBpbmdzUHRyKCkpOwoKICAgIHRoaXMuX2NvbXB1dGVkQ29sdW1uU3BhbnMgPSB0cnVlOwogIH0KICAvKioKICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWQKICAgKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3QKICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczoKICAgKgogICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXIKICAgKiAgICAgaXMgMS1iYXNlZC4KICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBjb2x1bW4KICAgKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuCiAgICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yCiAgICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGUKICAgKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZQogICAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC4KICAgKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy4KICAgKgogICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6CiAgICoKICAgKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuCiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlCiAgICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuCiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZQogICAqICAgICBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuCiAgICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLgogICAqLwoKCiAgb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykgewogICAgY29uc3QgbmVlZGxlID0gewogICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgImxpbmUiKSwKICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgImNvbHVtbiIpCiAgICB9OwoKICAgIGlmIChuZWVkbGUuZ2VuZXJhdGVkTGluZSA8IDEpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJMaW5lIG51bWJlcnMgbXVzdCBiZSA+PSAxIik7CiAgICB9CgogICAgaWYgKG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gPCAwKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiQ29sdW1uIG51bWJlcnMgbXVzdCBiZSA+PSAwIik7CiAgICB9CgogICAgbGV0IGJpYXMgPSB1dGlsLmdldEFyZyhhQXJncywgImJpYXMiLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCk7CgogICAgaWYgKGJpYXMgPT0gbnVsbCkgewogICAgICBiaWFzID0gU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQ7CiAgICB9CgogICAgbGV0IG1hcHBpbmc7CgogICAgdGhpcy5fd2FzbS53aXRoTWFwcGluZ0NhbGxiYWNrKG0gPT4gbWFwcGluZyA9IG0sICgpID0+IHsKICAgICAgdGhpcy5fd2FzbS5leHBvcnRzLm9yaWdpbmFsX2xvY2F0aW9uX2Zvcih0aGlzLl9nZXRNYXBwaW5nc1B0cigpLCBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtIDEsIG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4sIGJpYXMpOwogICAgfSk7CgogICAgaWYgKG1hcHBpbmcpIHsKICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHsKICAgICAgICBsZXQgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgInNvdXJjZSIsIG51bGwpOwoKICAgICAgICBpZiAoc291cmNlICE9PSBudWxsKSB7CiAgICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmF0KHNvdXJjZSk7CiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwodGhpcy5zb3VyY2VSb290LCBzb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7CiAgICAgICAgfQoKICAgICAgICBsZXQgbmFtZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICJuYW1lIiwgbnVsbCk7CgogICAgICAgIGlmIChuYW1lICE9PSBudWxsKSB7CiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuYXQobmFtZSk7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gewogICAgICAgICAgc291cmNlLAogICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgIm9yaWdpbmFsTGluZSIsIG51bGwpLAogICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAib3JpZ2luYWxDb2x1bW4iLCBudWxsKSwKICAgICAgICAgIG5hbWUKICAgICAgICB9OwogICAgICB9CiAgICB9CgogICAgcmV0dXJuIHsKICAgICAgc291cmNlOiBudWxsLAogICAgICBsaW5lOiBudWxsLAogICAgICBjb2x1bW46IG51bGwsCiAgICAgIG5hbWU6IG51bGwKICAgIH07CiAgfQogIC8qKgogICAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZQogICAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLgogICAqLwoKCiAgaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7CiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQoKICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+PSB0aGlzLl9zb3VyY2VzLnNpemUoKSAmJiAhdGhpcy5zb3VyY2VzQ29udGVudC5zb21lKGZ1bmN0aW9uIChzYykgewogICAgICByZXR1cm4gc2MgPT0gbnVsbDsKICAgIH0pOwogIH0KICAvKioKICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGUKICAgKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzCiAgICogYXZhaWxhYmxlLgogICAqLwoKCiAgc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7CiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CgogICAgY29uc3QgaW5kZXggPSB0aGlzLl9maW5kU291cmNlSW5kZXgoYVNvdXJjZSk7CgogICAgaWYgKGluZGV4ID49IDApIHsKICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbaW5kZXhdOwogICAgfQoKICAgIGxldCByZWxhdGl2ZVNvdXJjZSA9IGFTb3VyY2U7CgogICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7CiAgICAgIHJlbGF0aXZlU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHJlbGF0aXZlU291cmNlKTsKICAgIH0KCiAgICBsZXQgdXJsOwoKICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkgewogICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvcgogICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0bwogICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWUKICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LgogICAgICBjb25zdCBmaWxlVXJpQWJzUGF0aCA9IHJlbGF0aXZlU291cmNlLnJlcGxhY2UoL15maWxlOlwvXC8vLCAiIik7CgogICAgICBpZiAodXJsLnNjaGVtZSA9PSAiZmlsZSIgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV07CiAgICAgIH0KCiAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09ICIvIikgJiYgdGhpcy5fc291cmNlcy5oYXMoIi8iICsgcmVsYXRpdmVTb3VyY2UpKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKCIvIiArIHJlbGF0aXZlU291cmNlKV07CiAgICAgIH0KICAgIH0gLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IGZyb20KICAgIC8vIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvci4gSW4gdGhhdCBjYXNlLCB3ZQogICAgLy8gZG9uJ3Qgd2FudCB0byB0aHJvdyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBzb3VyY2UgLSB3ZSBqdXN0IHdhbnQgdG8KICAgIC8vIHJldHVybiBudWxsLCBzbyB3ZSBwcm92aWRlIGEgZmxhZyB0byBleGl0IGdyYWNlZnVsbHkuCgoKICAgIGlmIChudWxsT25NaXNzaW5nKSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfQoKICAgIHRocm93IG5ldyBFcnJvcignIicgKyByZWxhdGl2ZVNvdXJjZSArICciIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpOwogIH0KICAvKioKICAgKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLAogICAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aAogICAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczoKICAgKgogICAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLgogICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlcgogICAqICAgICBpcyAxLWJhc2VkLgogICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgY29sdW1uCiAgICogICAgIG51bWJlciBpcyAwLWJhc2VkLgogICAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvcgogICAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlCiAgICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmUKICAgKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuCiAgICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuCiAgICoKICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOgogICAqCiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZQogICAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLgogICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLgogICAqICAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLgogICAqLwoKCiAgZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHsKICAgIGxldCBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgInNvdXJjZSIpOwogICAgc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KHNvdXJjZSk7CgogICAgaWYgKHNvdXJjZSA8IDApIHsKICAgICAgcmV0dXJuIHsKICAgICAgICBsaW5lOiBudWxsLAogICAgICAgIGNvbHVtbjogbnVsbCwKICAgICAgICBsYXN0Q29sdW1uOiBudWxsCiAgICAgIH07CiAgICB9CgogICAgY29uc3QgbmVlZGxlID0gewogICAgICBzb3VyY2UsCiAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICJsaW5lIiksCiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgImNvbHVtbiIpCiAgICB9OwoKICAgIGlmIChuZWVkbGUub3JpZ2luYWxMaW5lIDwgMSkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIkxpbmUgbnVtYmVycyBtdXN0IGJlID49IDEiKTsKICAgIH0KCiAgICBpZiAobmVlZGxlLm9yaWdpbmFsQ29sdW1uIDwgMCkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIkNvbHVtbiBudW1iZXJzIG11c3QgYmUgPj0gMCIpOwogICAgfQoKICAgIGxldCBiaWFzID0gdXRpbC5nZXRBcmcoYUFyZ3MsICJiaWFzIiwgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpOwoKICAgIGlmIChiaWFzID09IG51bGwpIHsKICAgICAgYmlhcyA9IFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EOwogICAgfQoKICAgIGxldCBtYXBwaW5nOwoKICAgIHRoaXMuX3dhc20ud2l0aE1hcHBpbmdDYWxsYmFjayhtID0+IG1hcHBpbmcgPSBtLCAoKSA9PiB7CiAgICAgIHRoaXMuX3dhc20uZXhwb3J0cy5nZW5lcmF0ZWRfbG9jYXRpb25fZm9yKHRoaXMuX2dldE1hcHBpbmdzUHRyKCksIG5lZWRsZS5zb3VyY2UsIG5lZWRsZS5vcmlnaW5hbExpbmUgLSAxLCBuZWVkbGUub3JpZ2luYWxDb2x1bW4sIGJpYXMpOwogICAgfSk7CgogICAgaWYgKG1hcHBpbmcpIHsKICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBuZWVkbGUuc291cmNlKSB7CiAgICAgICAgbGV0IGxhc3RDb2x1bW4gPSBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW47CgogICAgICAgIGlmICh0aGlzLl9jb21wdXRlZENvbHVtblNwYW5zICYmIGxhc3RDb2x1bW4gPT09IG51bGwpIHsKICAgICAgICAgIGxhc3RDb2x1bW4gPSBJbmZpbml0eTsKICAgICAgICB9CgogICAgICAgIHJldHVybiB7CiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAiZ2VuZXJhdGVkTGluZSIsIG51bGwpLAogICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAiZ2VuZXJhdGVkQ29sdW1uIiwgbnVsbCksCiAgICAgICAgICBsYXN0Q29sdW1uCiAgICAgICAgfTsKICAgICAgfQogICAgfQoKICAgIHJldHVybiB7CiAgICAgIGxpbmU6IG51bGwsCiAgICAgIGNvbHVtbjogbnVsbCwKICAgICAgbGFzdENvbHVtbjogbnVsbAogICAgfTsKICB9Cgp9CgpCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyOwpleHBvcnRzLkJhc2ljU291cmNlTWFwQ29uc3VtZXIgPSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyOwovKioKICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaAogKiB3ZSBjYW4gcXVlcnkgZm9yIGluZm9ybWF0aW9uLiBJdCBkaWZmZXJzIGZyb20gQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpbgogKiB0aGF0IGl0IHRha2VzICJpbmRleGVkIiBzb3VyY2UgbWFwcyAoaS5lLiBvbmVzIHdpdGggYSAic2VjdGlvbnMiIGZpZWxkKSBhcwogKiBpbnB1dC4KICoKICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyBhIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3IgYWxyZWFkeQogKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5CiAqIGhhdmUgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOgogKgogKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy4KICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC4KICogICAtIHNlY3Rpb25zOiBBIGxpc3Qgb2Ygc2VjdGlvbiBkZWZpbml0aW9ucy4KICoKICogRWFjaCB2YWx1ZSB1bmRlciB0aGUgInNlY3Rpb25zIiBmaWVsZCBoYXMgdHdvIGZpZWxkczoKICogICAtIG9mZnNldDogVGhlIG9mZnNldCBpbnRvIHRoZSBvcmlnaW5hbCBzcGVjaWZpZWQgYXQgd2hpY2ggdGhpcyBzZWN0aW9uCiAqICAgICAgIGJlZ2lucyB0byBhcHBseSwgZGVmaW5lZCBhcyBhbiBvYmplY3Qgd2l0aCBhICJsaW5lIiBhbmQgImNvbHVtbiIKICogICAgICAgZmllbGQuCiAqICAgLSBtYXA6IEEgc291cmNlIG1hcCBkZWZpbml0aW9uLiBUaGlzIHNvdXJjZSBtYXAgY291bGQgYWxzbyBiZSBpbmRleGVkLAogKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLgogKgogKiBJbnN0ZWFkIG9mIHRoZSAibWFwIiBmaWVsZCwgaXQncyBhbHNvIHBvc3NpYmxlIHRvIGhhdmUgYSAidXJsIiBmaWVsZAogKiBzcGVjaWZ5aW5nIGEgVVJMIHRvIHJldHJpZXZlIGEgc291cmNlIG1hcCBmcm9tLCBidXQgdGhhdCdzIGN1cnJlbnRseQogKiB1bnN1cHBvcnRlZC4KICoKICogSGVyZSdzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdLCBidXQKICogbW9kaWZpZWQgdG8gb21pdCBhIHNlY3Rpb24gd2hpY2ggdXNlcyB0aGUgInVybCIgZmllbGQuCiAqCiAqICB7CiAqICAgIHZlcnNpb24gOiAzLAogKiAgICBmaWxlOiAiYXBwLmpzIiwKICogICAgc2VjdGlvbnM6IFt7CiAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sCiAqICAgICAgbWFwOiB7CiAqICAgICAgICB2ZXJzaW9uIDogMywKICogICAgICAgIGZpbGU6ICJzZWN0aW9uLmpzIiwKICogICAgICAgIHNvdXJjZXM6IFsiZm9vLmpzIiwgImJhci5qcyJdLAogKiAgICAgICAgbmFtZXM6IFsic3JjIiwgIm1hcHMiLCAiYXJlIiwgImZ1biJdLAogKiAgICAgICAgbWFwcGluZ3M6ICJBQUFBLEU7O0FCQ0RFOyIKICogICAgICB9CiAqICAgIH1dLAogKiAgfQogKgogKiBUaGUgc2Vjb25kIHBhcmFtZXRlciwgaWYgZ2l2ZW4sIGlzIGEgc3RyaW5nIHdob3NlIHZhbHVlIGlzIHRoZSBVUkwKICogYXQgd2hpY2ggdGhlIHNvdXJjZSBtYXAgd2FzIGZvdW5kLiAgVGhpcyBVUkwgaXMgdXNlZCB0byBjb21wdXRlIHRoZQogKiBzb3VyY2VzIGFycmF5LgogKgogKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdCNoZWFkaW5nPWguNTM1ZXMzeGVwcmd0CiAqLwoKY2xhc3MgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGV4dGVuZHMgU291cmNlTWFwQ29uc3VtZXIgewogIGNvbnN0cnVjdG9yKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHsKICAgIHJldHVybiBzdXBlcihJTlRFUk5BTCkudGhlbih0aGF0ID0+IHsKICAgICAgbGV0IHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7CgogICAgICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICJzdHJpbmciKSB7CiAgICAgICAgc291cmNlTWFwID0gdXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApOwogICAgICB9CgogICAgICBjb25zdCB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAidmVyc2lvbiIpOwogICAgICBjb25zdCBzZWN0aW9ucyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgInNlY3Rpb25zIik7CgogICAgICBpZiAodmVyc2lvbiAhPSB0aGF0Ll92ZXJzaW9uKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJVbnN1cHBvcnRlZCB2ZXJzaW9uOiAiICsgdmVyc2lvbik7CiAgICAgIH0KCiAgICAgIHRoYXQuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTsKICAgICAgdGhhdC5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTsKICAgICAgdGhhdC5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDsKICAgICAgdGhhdC5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsOwogICAgICB0aGF0Ll9fZ2VuZXJhdGVkTWFwcGluZ3NVbnNvcnRlZCA9IG51bGw7CiAgICAgIHRoYXQuX19vcmlnaW5hbE1hcHBpbmdzVW5zb3J0ZWQgPSBudWxsOwogICAgICBsZXQgbGFzdE9mZnNldCA9IHsKICAgICAgICBsaW5lOiAtMSwKICAgICAgICBjb2x1bW46IDAKICAgICAgfTsKICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHNlY3Rpb25zLm1hcChzID0+IHsKICAgICAgICBpZiAocy51cmwpIHsKICAgICAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LgogICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlN1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuIik7CiAgICAgICAgfQoKICAgICAgICBjb25zdCBvZmZzZXQgPSB1dGlsLmdldEFyZyhzLCAib2Zmc2V0Iik7CiAgICAgICAgY29uc3Qgb2Zmc2V0TGluZSA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgImxpbmUiKTsKICAgICAgICBjb25zdCBvZmZzZXRDb2x1bW4gPSB1dGlsLmdldEFyZyhvZmZzZXQsICJjb2x1bW4iKTsKCiAgICAgICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHwgb2Zmc2V0TGluZSA9PT0gbGFzdE9mZnNldC5saW5lICYmIG9mZnNldENvbHVtbiA8IGxhc3RPZmZzZXQuY29sdW1uKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlNlY3Rpb24gb2Zmc2V0cyBtdXN0IGJlIG9yZGVyZWQgYW5kIG5vbi1vdmVybGFwcGluZy4iKTsKICAgICAgICB9CgogICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7CiAgICAgICAgY29uc3QgY29ucyA9IG5ldyBTb3VyY2VNYXBDb25zdW1lcih1dGlsLmdldEFyZyhzLCAibWFwIiksIGFTb3VyY2VNYXBVUkwpOwogICAgICAgIHJldHVybiBjb25zLnRoZW4oY29uc3VtZXIgPT4gewogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgZ2VuZXJhdGVkT2Zmc2V0OiB7CiAgICAgICAgICAgICAgLy8gVGhlIG9mZnNldCBmaWVsZHMgYXJlIDAtYmFzZWQsIGJ1dCB3ZSB1c2UgMS1iYXNlZCBpbmRpY2VzIHdoZW4KICAgICAgICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS4KICAgICAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBvZmZzZXRMaW5lICsgMSwKICAgICAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG9mZnNldENvbHVtbiArIDEKICAgICAgICAgICAgfSwKICAgICAgICAgICAgY29uc3VtZXIKICAgICAgICAgIH07CiAgICAgICAgfSk7CiAgICAgIH0pKS50aGVuKHMgPT4gewogICAgICAgIHRoYXQuX3NlY3Rpb25zID0gczsKICAgICAgICByZXR1cm4gdGhhdDsKICAgICAgfSk7CiAgICB9KTsKICB9IC8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlCiAgLy8gcGFyc2VkIG1hcHBpbmcgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIG1hcCdzICJtYXBwaW5ncyIgYXR0cmlidXRlLiBUaGV5CiAgLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kCiAgLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzCiAgLy8gYW5kIGNyZWF0ZSB0aGVzZSBhcnJheXMgb25jZSBxdWVyaWVkIGZvciBhIHNvdXJjZSBsb2NhdGlvbi4gV2UganVtcCB0aHJvdWdoCiAgLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nCiAgLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LgogIC8vCiAgLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybToKICAvLwogIC8vICAgICB7CiAgLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSwKICAvLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSwKICAvLyAgICAgICBzb3VyY2U6IFRoZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSB0aGF0IGdlbmVyYXRlZCB0aGlzCiAgLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLAogIC8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdAogIC8vICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSwKICAvLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0CiAgLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsCiAgLy8gICAgICAgbmFtZTogVGhlIG5hbWUgb2YgdGhlIG9yaWdpbmFsIHN5bWJvbCB3aGljaCBnZW5lcmF0ZWQgdGhpcyBjaHVuayBvZgogIC8vICAgICAgICAgICAgIGNvZGUuCiAgLy8gICAgIH0KICAvLwogIC8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmUKICAvLyBgbnVsbGAuCiAgLy8KICAvLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLgogIC8vCiAgLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMuCgoKICBnZXQgX2dlbmVyYXRlZE1hcHBpbmdzKCkgewogICAgaWYgKCF0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MpIHsKICAgICAgdGhpcy5fc29ydEdlbmVyYXRlZE1hcHBpbmdzKCk7CiAgICB9CgogICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nczsKICB9CgogIGdldCBfb3JpZ2luYWxNYXBwaW5ncygpIHsKICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHsKICAgICAgdGhpcy5fc29ydE9yaWdpbmFsTWFwcGluZ3MoKTsKICAgIH0KCiAgICByZXR1cm4gdGhpcy5fX29yaWdpbmFsTWFwcGluZ3M7CiAgfQoKICBnZXQgX2dlbmVyYXRlZE1hcHBpbmdzVW5zb3J0ZWQoKSB7CiAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc1Vuc29ydGVkKSB7CiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7CiAgICB9CgogICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc1Vuc29ydGVkOwogIH0KCiAgZ2V0IF9vcmlnaW5hbE1hcHBpbmdzVW5zb3J0ZWQoKSB7CiAgICBpZiAoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzVW5zb3J0ZWQpIHsKICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTsKICAgIH0KCiAgICByZXR1cm4gdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NVbnNvcnRlZDsKICB9CgogIF9zb3J0R2VuZXJhdGVkTWFwcGluZ3MoKSB7CiAgICBjb25zdCBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzVW5zb3J0ZWQ7CiAgICBtYXBwaW5ncy5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpOwogICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbWFwcGluZ3M7CiAgfQoKICBfc29ydE9yaWdpbmFsTWFwcGluZ3MoKSB7CiAgICBjb25zdCBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NVbnNvcnRlZDsKICAgIG1hcHBpbmdzLnNvcnQodXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7CiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG1hcHBpbmdzOwogIH0KICAvKioKICAgKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLgogICAqLwoKCiAgZ2V0IHNvdXJjZXMoKSB7CiAgICBjb25zdCBzb3VyY2VzID0gW107CgogICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykgewogICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXMubGVuZ3RoOyBqKyspIHsKICAgICAgICBzb3VyY2VzLnB1c2godGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlc1tqXSk7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gc291cmNlczsKICB9CiAgLyoqCiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkCiAgICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0CiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6CiAgICoKICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyCiAgICogICAgIGlzIDEtYmFzZWQuCiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgY29sdW1uCiAgICogICAgIG51bWJlciBpcyAwLWJhc2VkLgogICAqCiAgICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczoKICAgKgogICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC4KICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGUKICAgKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC4KICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlCiAgICogICAgIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC4KICAgKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuCiAgICovCgoKICBvcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7CiAgICBjb25zdCBuZWVkbGUgPSB7CiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAibGluZSIpLAogICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAiY29sdW1uIikKICAgIH07IC8vIEZpbmQgdGhlIHNlY3Rpb24gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uIHdlJ3JlIHRyeWluZyB0byBtYXAKICAgIC8vIHRvIGFuIG9yaWdpbmFsIHBvc2l0aW9uLgoKICAgIGNvbnN0IHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucywgZnVuY3Rpb24gKGFOZWVkbGUsIHNlY3Rpb24pIHsKICAgICAgY29uc3QgY21wID0gYU5lZWRsZS5nZW5lcmF0ZWRMaW5lIC0gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZTsKCiAgICAgIGlmIChjbXApIHsKICAgICAgICByZXR1cm4gY21wOwogICAgICB9CgogICAgICByZXR1cm4gYU5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW47CiAgICB9KTsKICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tzZWN0aW9uSW5kZXhdOwoKICAgIGlmICghc2VjdGlvbikgewogICAgICByZXR1cm4gewogICAgICAgIHNvdXJjZTogbnVsbCwKICAgICAgICBsaW5lOiBudWxsLAogICAgICAgIGNvbHVtbjogbnVsbCwKICAgICAgICBuYW1lOiBudWxsCiAgICAgIH07CiAgICB9CgogICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7CiAgICAgIGxpbmU6IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC0gKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSwKICAgICAgY29sdW1uOiBuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC0gKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMSA6IDApLAogICAgICBiaWFzOiBhQXJncy5iaWFzCiAgICB9KTsKICB9CiAgLyoqCiAgICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlCiAgICogbWFwLCBmYWxzZSBvdGhlcndpc2UuCiAgICovCgoKICBoYXNDb250ZW50c09mQWxsU291cmNlcygpIHsKICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAocykgewogICAgICByZXR1cm4gcy5jb25zdW1lci5oYXNDb250ZW50c09mQWxsU291cmNlcygpOwogICAgfSk7CiAgfQogIC8qKgogICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZQogICAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXMKICAgKiBhdmFpbGFibGUuCiAgICovCgoKICBzb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHsKICAgICAgY29uc3Qgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldOwogICAgICBjb25zdCBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpOwoKICAgICAgaWYgKGNvbnRlbnQpIHsKICAgICAgICByZXR1cm4gY29udGVudDsKICAgICAgfQogICAgfQoKICAgIGlmIChudWxsT25NaXNzaW5nKSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfQoKICAgIHRocm93IG5ldyBFcnJvcignIicgKyBhU291cmNlICsgJyIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7CiAgfQogIC8qKgogICAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsCiAgICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoCiAgICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOgogICAqCiAgICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuCiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyCiAgICogICAgIGlzIDEtYmFzZWQuCiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBjb2x1bW4KICAgKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuCiAgICoKICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOgogICAqCiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZQogICAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLgogICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLgogICAqICAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLgogICAqLwoKCiAgZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHsKICAgICAgY29uc3Qgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldOyAvLyBPbmx5IGNvbnNpZGVyIHRoaXMgc2VjdGlvbiBpZiB0aGUgcmVxdWVzdGVkIHNvdXJjZSBpcyBpbiB0aGUgbGlzdCBvZgogICAgICAvLyBzb3VyY2VzIG9mIHRoZSBjb25zdW1lci4KCiAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLl9maW5kU291cmNlSW5kZXgodXRpbC5nZXRBcmcoYUFyZ3MsICJzb3VyY2UiKSkgPT09IC0xKSB7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KCiAgICAgIGNvbnN0IGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7CgogICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHsKICAgICAgICBjb25zdCByZXQgPSB7CiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICsgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSwKICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkUG9zaXRpb24uY29sdW1uICsgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmUgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxIDogMCkKICAgICAgICB9OwogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gewogICAgICBsaW5lOiBudWxsLAogICAgICBjb2x1bW46IG51bGwKICAgIH07CiAgfQogIC8qKgogICAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHkKICAgKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQKICAgKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLgogICAqLwoKCiAgX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHsKICAgIGNvbnN0IGdlbmVyYXRlZE1hcHBpbmdzID0gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzVW5zb3J0ZWQgPSBbXTsKICAgIGNvbnN0IG9yaWdpbmFsTWFwcGluZ3MgPSB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc1Vuc29ydGVkID0gW107CgogICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykgewogICAgICBjb25zdCBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07CiAgICAgIGNvbnN0IHNlY3Rpb25NYXBwaW5ncyA9IFtdOwogICAgICBzZWN0aW9uLmNvbnN1bWVyLmVhY2hNYXBwaW5nKG0gPT4gc2VjdGlvbk1hcHBpbmdzLnB1c2gobSkpOwoKICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHsKICAgICAgICBjb25zdCBtYXBwaW5nID0gc2VjdGlvbk1hcHBpbmdzW2pdOyAvLyBUT0RPOiB0ZXN0IGlmIG51bGwgaXMgY29ycmVjdCBoZXJlLiAgVGhlIG9yaWdpbmFsIGNvZGUgdXNlZAogICAgICAgIC8vIGBzb3VyY2VgLCB3aGljaCB3b3VsZCBhY3R1YWxseSBoYXZlIGdvdHRlbiB1c2VkIGFzIG51bGwgYmVjYXVzZQogICAgICAgIC8vIHZhcidzIGdldCBob2lzdGVkLgogICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMzMzCgogICAgICAgIGxldCBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290LCBudWxsLCB0aGlzLl9zb3VyY2VNYXBVUkwpOwoKICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpOwoKICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTsKICAgICAgICBsZXQgbmFtZSA9IG51bGw7CgogICAgICAgIGlmIChtYXBwaW5nLm5hbWUpIHsKICAgICAgICAgIHRoaXMuX25hbWVzLmFkZChtYXBwaW5nLm5hbWUpOwoKICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSk7CiAgICAgICAgfSAvLyBUaGUgbWFwcGluZ3MgY29taW5nIGZyb20gdGhlIGNvbnN1bWVyIGZvciB0aGUgc2VjdGlvbiBoYXZlCiAgICAgICAgLy8gZ2VuZXJhdGVkIHBvc2l0aW9ucyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNlY3Rpb24sIHNvIHdlCiAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZAogICAgICAgIC8vIGdlbmVyYXRlZCBmaWxlLgoKCiAgICAgICAgY29uc3QgYWRqdXN0ZWRNYXBwaW5nID0gewogICAgICAgICAgc291cmNlLAogICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lICsgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSwKICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gKyAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbWFwcGluZy5nZW5lcmF0ZWRMaW5lID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMSA6IDApLAogICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSwKICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLAogICAgICAgICAgbmFtZQogICAgICAgIH07CiAgICAgICAgZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpOwoKICAgICAgICBpZiAodHlwZW9mIGFkanVzdGVkTWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9CgogIGVhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikgewogICAgY29uc3QgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7CiAgICBjb25zdCBvcmRlciA9IGFPcmRlciB8fCBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI7CiAgICBsZXQgbWFwcGluZ3M7CgogICAgc3dpdGNoIChvcmRlcikgewogICAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjoKICAgICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzOwogICAgICAgIGJyZWFrOwoKICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjoKICAgICAgICBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3M7CiAgICAgICAgYnJlYWs7CgogICAgICBkZWZhdWx0OgogICAgICAgIHRocm93IG5ldyBFcnJvcigiVW5rbm93biBvcmRlciBvZiBpdGVyYXRpb24uIik7CiAgICB9CgogICAgY29uc3Qgc291cmNlUm9vdCA9IHRoaXMuc291cmNlUm9vdDsKICAgIG1hcHBpbmdzLm1hcChmdW5jdGlvbiAobWFwcGluZykgewogICAgICBsZXQgc291cmNlID0gbnVsbDsKCiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPT0gbnVsbCkgewogICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpOwogICAgICAgIHNvdXJjZSA9IHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LCBzb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7CiAgICAgIH0KCiAgICAgIHJldHVybiB7CiAgICAgICAgc291cmNlLAogICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSwKICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLAogICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsCiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sCiAgICAgICAgbmFtZTogbWFwcGluZy5uYW1lID09PSBudWxsID8gbnVsbCA6IHRoaXMuX25hbWVzLmF0KG1hcHBpbmcubmFtZSkKICAgICAgfTsKICAgIH0sIHRoaXMpLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTsKICB9CiAgLyoqCiAgICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsICJuZWVkbGUiIG1hcHBpbmcgdGhhdAogICAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiAiaGF5c3RhY2siIG9mIG1hcHBpbmdzLgogICAqLwoKCiAgX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLCBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IsIGFCaWFzKSB7CiAgICAvLyBUbyByZXR1cm4gdGhlIHBvc2l0aW9uIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCB3ZSBtdXN0IGZpcnN0IGZpbmQgdGhlCiAgICAvLyBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHRoZW4gcmV0dXJuIHRoZSBvcHBvc2l0ZSBwb3NpdGlvbiBpdAogICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG8KICAgIC8vIGZpbmQgdGhlIGJlc3QgbWFwcGluZy4KICAgIGlmIChhTmVlZGxlW2FMaW5lTmFtZV0gPD0gMCkgewogICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAiICsgYU5lZWRsZVthTGluZU5hbWVdKTsKICAgIH0KCiAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7CiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkNvbHVtbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwLCBnb3QgIiArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTsKICAgIH0KCiAgICByZXR1cm4gYmluYXJ5U2VhcmNoLnNlYXJjaChhTmVlZGxlLCBhTWFwcGluZ3MsIGFDb21wYXJhdG9yLCBhQmlhcyk7CiAgfQoKICBhbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IoYUFyZ3MpIHsKICAgIGNvbnN0IGxpbmUgPSB1dGlsLmdldEFyZyhhQXJncywgImxpbmUiKTsgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nCiAgICAvLyByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBtYXBwaW5nIGxlc3MgdGhhbiB0aGUgbmVlZGxlLiBCeQogICAgLy8gc2V0dGluZyBuZWVkbGUub3JpZ2luYWxDb2x1bW4gdG8gMCwgd2UgdGh1cyBmaW5kIHRoZSBsYXN0IG1hcHBpbmcgZm9yCiAgICAvLyB0aGUgZ2l2ZW4gbGluZSwgcHJvdmlkZWQgc3VjaCBhIG1hcHBpbmcgZXhpc3RzLgoKICAgIGNvbnN0IG5lZWRsZSA9IHsKICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgInNvdXJjZSIpLAogICAgICBvcmlnaW5hbExpbmU6IGxpbmUsCiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgImNvbHVtbiIsIDApCiAgICB9OwogICAgbmVlZGxlLnNvdXJjZSA9IHRoaXMuX2ZpbmRTb3VyY2VJbmRleChuZWVkbGUuc291cmNlKTsKCiAgICBpZiAobmVlZGxlLnNvdXJjZSA8IDApIHsKICAgICAgcmV0dXJuIFtdOwogICAgfQoKICAgIGlmIChuZWVkbGUub3JpZ2luYWxMaW5lIDwgMSkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIkxpbmUgbnVtYmVycyBtdXN0IGJlID49IDEiKTsKICAgIH0KCiAgICBpZiAobmVlZGxlLm9yaWdpbmFsQ29sdW1uIDwgMCkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIkNvbHVtbiBudW1iZXJzIG11c3QgYmUgPj0gMCIpOwogICAgfQoKICAgIGNvbnN0IG1hcHBpbmdzID0gW107CgogICAgbGV0IGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLCB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLCAib3JpZ2luYWxMaW5lIiwgIm9yaWdpbmFsQ29sdW1uIiwgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucywgYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EKTsKCiAgICBpZiAoaW5kZXggPj0gMCkgewogICAgICBsZXQgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdOwoKICAgICAgaWYgKGFBcmdzLmNvbHVtbiA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgY29uc3Qgb3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7IC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvCiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSBmb3VuZC4gU2luY2UKICAgICAgICAvLyBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yCiAgICAgICAgLy8gdGhlIGxpbmUgd2UgZm91bmQuCgogICAgICAgIHdoaWxlIChtYXBwaW5nICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBvcmlnaW5hbExpbmUpIHsKICAgICAgICAgIGxldCBsYXN0Q29sdW1uID0gbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uOwoKICAgICAgICAgIGlmICh0aGlzLl9jb21wdXRlZENvbHVtblNwYW5zICYmIGxhc3RDb2x1bW4gPT09IG51bGwpIHsKICAgICAgICAgICAgbGFzdENvbHVtbiA9IEluZmluaXR5OwogICAgICAgICAgfQoKICAgICAgICAgIG1hcHBpbmdzLnB1c2goewogICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAiZ2VuZXJhdGVkTGluZSIsIG51bGwpLAogICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICJnZW5lcmF0ZWRDb2x1bW4iLCBudWxsKSwKICAgICAgICAgICAgbGFzdENvbHVtbgogICAgICAgICAgfSk7CiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3Qgb3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uOyAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50bwogICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2Ugd2VyZSBzZWFyY2hpbmcgZm9yLgogICAgICAgIC8vIFNpbmNlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3IKICAgICAgICAvLyB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci4KCiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IGxpbmUgJiYgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9PSBvcmlnaW5hbENvbHVtbikgewogICAgICAgICAgbGV0IGxhc3RDb2x1bW4gPSBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW47CgogICAgICAgICAgaWYgKHRoaXMuX2NvbXB1dGVkQ29sdW1uU3BhbnMgJiYgbGFzdENvbHVtbiA9PT0gbnVsbCkgewogICAgICAgICAgICBsYXN0Q29sdW1uID0gSW5maW5pdHk7CiAgICAgICAgICB9CgogICAgICAgICAgbWFwcGluZ3MucHVzaCh7CiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICJnZW5lcmF0ZWRMaW5lIiwgbnVsbCksCiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgImdlbmVyYXRlZENvbHVtbiIsIG51bGwpLAogICAgICAgICAgICBsYXN0Q29sdW1uCiAgICAgICAgICB9KTsKICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdOwogICAgICAgIH0KICAgICAgfQogICAgfQoKICAgIHJldHVybiBtYXBwaW5nczsKICB9CgogIGRlc3Ryb3koKSB7CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7CiAgICAgIHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLmRlc3Ryb3koKTsKICAgIH0KICB9Cgp9CgpleHBvcnRzLkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciA9IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcjsKLyoKICogQ2hlYXQgdG8gZ2V0IGFyb3VuZCBpbnRlci10d2luZ2xlZCBjbGFzc2VzLiAgYGZhY3RvcnkoKWAgY2FuIGJlIGF0IHRoZSBlbmQKICogd2hlcmUgaXQgaGFzIGFjY2VzcyB0byBub24taG9pc3RlZCBjbGFzc2VzLCBidXQgaXQgZ2V0cyBob2lzdGVkIGl0c2VsZi4KICovCgpmdW5jdGlvbiBfZmFjdG9yeShhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7CiAgbGV0IHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7CgogIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gInN0cmluZyIpIHsKICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTsKICB9CgogIGNvbnN0IGNvbnN1bWVyID0gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGwgPyBuZXcgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkgOiBuZXcgQmFzaWNTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpOwogIHJldHVybiBQcm9taXNlLnJlc29sdmUoY29uc3VtZXIpOwp9CgpmdW5jdGlvbiBfZmFjdG9yeUJTTShhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7CiAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKTsKfQ=="},{"version":3,"sources":["E:/前端学习/2020-bloom/web-project/5.性能优化/5-3.优化loader性能/node_modules/_source-map@0.7.3@source-map/lib/source-map-consumer.js"],"names":["util","require","binarySearch","ArraySet","base64VLQ","readWasm","wasm","INTERNAL","Symbol","SourceMapConsumer","constructor","aSourceMap","aSourceMapURL","Promise","resolve","_factory","initialize","opts","fromSourceMap","_factoryBSM","with","rawSourceMap","sourceMapUrl","f","consumer","promise","then","c","x","destroy","e","_parseMappings","aStr","aSourceRoot","Error","eachMapping","aCallback","aContext","aOrder","allGeneratedPositionsFor","aArgs","prototype","_version","GENERATED_ORDER","ORIGINAL_ORDER","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","exports","BasicSourceMapConsumer","that","sourceMap","parseSourceMapInput","version","getArg","sources","names","sourceRoot","sourcesContent","mappings","file","normalize","map","String","source","isAbsolute","relative","_names","fromArray","_sources","_absoluteSources","toArray","s","computeSourceURL","_mappings","_sourceMapURL","_computedColumnSpans","_mappingsPtr","_wasm","w","_findSourceIndex","aSource","relativeSource","has","indexOf","i","length","toString","slice","_getMappingsPtr","size","mappingsBufPtr","allocate_mappings","mappingsBuf","Uint8Array","memory","buffer","charCodeAt","mappingsPtr","parse_mappings","error","get_last_error","msg","context","order","withMappingCallback","mapping","at","name","call","by_generated_location","by_original_location","originalLine","originalColumn","column","m","lastColumn","lastGeneratedColumn","Infinity","push","line","generatedLine","generatedColumn","all_generated_locations_for","free_mappings","computeColumnSpans","compute_column_spans","originalPositionFor","needle","bias","original_location_for","hasContentsOfAllSources","some","sc","sourceContentFor","nullOnMissing","index","url","urlParse","fileUriAbsPath","replace","scheme","path","generatedPositionFor","generated_location_for","IndexedSourceMapConsumer","sections","__generatedMappings","__originalMappings","__generatedMappingsUnsorted","__originalMappingsUnsorted","lastOffset","all","offset","offsetLine","offsetColumn","cons","generatedOffset","_sections","_generatedMappings","_sortGeneratedMappings","_originalMappings","_sortOriginalMappings","_generatedMappingsUnsorted","_originalMappingsUnsorted","sort","compareByGeneratedPositionsDeflated","compareByOriginalPositions","j","sectionIndex","search","aNeedle","section","cmp","every","content","generatedPosition","ret","generatedMappings","originalMappings","sectionMappings","add","adjustedMapping","forEach","_findMapping","aMappings","aLineName","aColumnName","aComparator","aBias","TypeError","undefined"],"mappings":"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","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst util = require(\"./util\");\nconst binarySearch = require(\"./binary-search\");\nconst ArraySet = require(\"./array-set\").ArraySet;\nconst base64VLQ = require(\"./base64-vlq\"); // eslint-disable-line no-unused-vars\nconst readWasm = require(\"../lib/read-wasm\");\nconst wasm = require(\"./wasm\");\n\nconst INTERNAL = Symbol(\"smcInternal\");\n\nclass SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    // If the constructor was called by super(), just return Promise<this>.\n    // Yes, this is a hack to retain the pre-existing API of the base-class\n    // constructor also being an async factory function.\n    if (aSourceMap == INTERNAL) {\n      return Promise.resolve(this);\n    }\n\n    return _factory(aSourceMap, aSourceMapURL);\n  }\n\n  static initialize(opts) {\n    readWasm.initialize(opts[\"lib/mappings.wasm\"]);\n  }\n\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return _factoryBSM(aSourceMap, aSourceMapURL);\n  }\n\n  /**\n   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`\n   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async\n   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait\n   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return\n   * value.\n   *\n   * You must not use the consumer after `f` completes!\n   *\n   * By using `with`, you do not have to remember to manually call `destroy` on\n   * the consumer, since it will be called automatically once `f` completes.\n   *\n   * ```js\n   * const xSquared = await SourceMapConsumer.with(\n   *   myRawSourceMap,\n   *   null,\n   *   async function (consumer) {\n   *     // Use `consumer` inside here and don't worry about remembering\n   *     // to call `destroy`.\n   *\n   *     const x = await whatever(consumer);\n   *     return x * x;\n   *   }\n   * );\n   *\n   * // You may not use that `consumer` anymore out here; it has\n   * // been destroyed. But you can use `xSquared`.\n   * console.log(xSquared);\n   * ```\n   */\n  static with(rawSourceMap, sourceMapUrl, f) {\n    // Note: The `acorn` version that `webpack` currently depends on doesn't\n    // support `async` functions, and the nodes that we support don't all have\n    // `.finally`. Therefore, this is written a bit more convolutedly than it\n    // should really be.\n\n    let consumer = null;\n    const promise = new SourceMapConsumer(rawSourceMap, sourceMapUrl);\n    return promise\n      .then(c => {\n        consumer = c;\n        return f(c);\n      })\n      .then(x => {\n        if (consumer) {\n          consumer.destroy();\n        }\n        return x;\n      }, e => {\n        if (consumer) {\n          consumer.destroy();\n        }\n        throw e;\n      });\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  }\n\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n  eachMapping(aCallback, aContext, aOrder) {\n    throw new Error(\"Subclasses must implement eachMapping\");\n  }\n\n  /**\n   * Returns all generated line and column information for the original source,\n   * line, and column provided. If no column is provided, returns all mappings\n   * corresponding to a either the line we are searching for or the next\n   * closest line that has any mappings. Otherwise, returns all mappings\n   * corresponding to the given line and either the column we are searching for\n   * or the next closest column that has any offsets.\n   *\n   * The only argument is an object with the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number is 1-based.\n   *   - column: Optional. the column number in the original source.\n   *    The column number is 0-based.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *    line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *    The column number is 0-based.\n   */\n  allGeneratedPositionsFor(aArgs) {\n    throw new Error(\"Subclasses must implement allGeneratedPositionsFor\");\n  }\n\n  destroy() {\n    throw new Error(\"Subclasses must implement destroy\");\n  }\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nclass BasicSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      let sources = util.getArg(sourceMap, \"sources\");\n      // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n      // requires the array) to play nice here.\n      const names = util.getArg(sourceMap, \"names\", []);\n      let sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n      const sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n      const mappings = util.getArg(sourceMap, \"mappings\");\n      const file = util.getArg(sourceMap, \"file\", null);\n\n      // Once again, Sass deviates from the spec and supplies the version as a\n      // string rather than a number, so we use loose equality checking here.\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      if (sourceRoot) {\n        sourceRoot = util.normalize(sourceRoot);\n      }\n\n      sources = sources\n        .map(String)\n        // Some source maps produce relative source paths like \"./foo.js\" instead of\n        // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n        // See bugzil.la/1090768.\n        .map(util.normalize)\n        // Always ensure that absolute sources are internally stored relative to\n        // the source root, if the source root is absolute. Not doing this would\n        // be particularly problematic when the source root is a prefix of the\n        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n        .map(function(source) {\n          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n            ? util.relative(sourceRoot, source)\n            : source;\n        });\n\n      // Pass `true` below to allow duplicate names and sources. While source maps\n      // are intended to be compressed and deduplicated, the TypeScript compiler\n      // sometimes generates source maps with duplicates in them. See Github issue\n      // #72 and bugzil.la/889492.\n      that._names = ArraySet.fromArray(names.map(String), true);\n      that._sources = ArraySet.fromArray(sources, true);\n\n      that._absoluteSources = that._sources.toArray().map(function(s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n      });\n\n      that.sourceRoot = sourceRoot;\n      that.sourcesContent = sourcesContent;\n      that._mappings = mappings;\n      that._sourceMapURL = aSourceMapURL;\n      that.file = file;\n\n      that._computedColumnSpans = false;\n      that._mappingsPtr = 0;\n      that._wasm = null;\n\n      return wasm().then(w => {\n        that._wasm = w;\n        return that;\n      });\n    });\n  }\n\n  /**\n   * Utility function to find the index of a source.  Returns -1 if not\n   * found.\n   */\n  _findSourceIndex(aSource) {\n    let relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    if (this._sources.has(relativeSource)) {\n      return this._sources.indexOf(relativeSource);\n    }\n\n    // Maybe aSource is an absolute URL as returned by |sources|.  In\n    // this case we can't simply undo the transform.\n    for (let i = 0; i < this._absoluteSources.length; ++i) {\n      if (this._absoluteSources[i] == aSource) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @param String aSourceMapURL\n   *        The URL at which the source map can be found (optional)\n   * @returns BasicSourceMapConsumer\n   */\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return new BasicSourceMapConsumer(aSourceMap.toString());\n  }\n\n  get sources() {\n    return this._absoluteSources.slice();\n  }\n\n  _getMappingsPtr() {\n    if (this._mappingsPtr === 0) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this._mappingsPtr;\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    const size = aStr.length;\n\n    const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);\n    const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);\n    for (let i = 0; i < size; i++) {\n      mappingsBuf[i] = aStr.charCodeAt(i);\n    }\n\n    const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);\n\n    if (!mappingsPtr) {\n      const error = this._wasm.exports.get_last_error();\n      let msg = `Error parsing mappings (code ${error}): `;\n\n      // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.\n      switch (error) {\n        case 1:\n          msg += \"the mappings contained a negative line, column, source index, or name index\";\n          break;\n        case 2:\n          msg += \"the mappings contained a number larger than 2**32\";\n          break;\n        case 3:\n          msg += \"reached EOF while in the middle of parsing a VLQ\";\n          break;\n        case 4:\n          msg += \"invalid base 64 character while parsing a VLQ\";\n          break;\n        default:\n          msg += \"unknown error code\";\n          break;\n      }\n\n      throw new Error(msg);\n    }\n\n    this._mappingsPtr = mappingsPtr;\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n    const sourceRoot = this.sourceRoot;\n\n    this._wasm.withMappingCallback(\n      mapping => {\n        if (mapping.source !== null) {\n          mapping.source = this._sources.at(mapping.source);\n          mapping.source = util.computeSourceURL(sourceRoot, mapping.source, this._sourceMapURL);\n\n          if (mapping.name !== null) {\n            mapping.name = this._names.at(mapping.name);\n          }\n        }\n\n        aCallback.call(context, mapping);\n      },\n      () => {\n        switch (order) {\n        case SourceMapConsumer.GENERATED_ORDER:\n          this._wasm.exports.by_generated_location(this._getMappingsPtr());\n          break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n          this._wasm.exports.by_original_location(this._getMappingsPtr());\n          break;\n        default:\n          throw new Error(\"Unknown order of iteration.\");\n        }\n      }\n    );\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    const originalLine = util.getArg(aArgs, \"line\");\n    const originalColumn = aArgs.column || 0;\n\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return [];\n    }\n\n    if (originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    this._wasm.withMappingCallback(\n      m => {\n        let lastColumn = m.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        mappings.push({\n          line: m.generatedLine,\n          column: m.generatedColumn,\n          lastColumn,\n        });\n      }, () => {\n        this._wasm.exports.all_generated_locations_for(\n          this._getMappingsPtr(),\n          source,\n          originalLine - 1,\n          \"column\" in aArgs,\n          originalColumn\n        );\n      }\n    );\n\n    return mappings;\n  }\n\n  destroy() {\n    if (this._mappingsPtr !== 0) {\n      this._wasm.exports.free_mappings(this._mappingsPtr);\n      this._mappingsPtr = 0;\n    }\n  }\n\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n  computeColumnSpans() {\n    if (this._computedColumnSpans) {\n      return;\n    }\n\n    this._wasm.exports.compute_column_spans(this._getMappingsPtr());\n    this._computedColumnSpans = true;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.generatedLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.generatedColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.original_location_for(\n        this._getMappingsPtr(),\n        needle.generatedLine - 1,\n        needle.generatedColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.generatedLine === needle.generatedLine) {\n        let source = util.getArg(mapping, \"source\", null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n\n        let name = util.getArg(mapping, \"name\", null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n\n        return {\n          source,\n          line: util.getArg(mapping, \"originalLine\", null),\n          column: util.getArg(mapping, \"originalColumn\", null),\n          name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function(sc) { return sc == null; });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    const index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    let relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    let url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      const fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n\n    throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    const needle = {\n      source,\n      originalLine: util.getArg(aArgs, \"line\"),\n      originalColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.generated_location_for(\n        this._getMappingsPtr(),\n        needle.source,\n        needle.originalLine - 1,\n        needle.originalColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.source === needle.source) {\n        let lastColumn = mapping.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        return {\n          line: util.getArg(mapping, \"generatedLine\", null),\n          column: util.getArg(mapping, \"generatedColumn\", null),\n          lastColumn,\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  }\n}\n\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nclass IndexedSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sections = util.getArg(sourceMap, \"sections\");\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      that._sources = new ArraySet();\n      that._names = new ArraySet();\n      that.__generatedMappings = null;\n      that.__originalMappings = null;\n      that.__generatedMappingsUnsorted = null;\n      that.__originalMappingsUnsorted = null;\n\n      let lastOffset = {\n        line: -1,\n        column: 0\n      };\n      return Promise.all(sections.map(s => {\n        if (s.url) {\n          // The url field will require support for asynchronicity.\n          // See https://github.com/mozilla/source-map/issues/16\n          throw new Error(\"Support for url field in sections not implemented.\");\n        }\n        const offset = util.getArg(s, \"offset\");\n        const offsetLine = util.getArg(offset, \"line\");\n        const offsetColumn = util.getArg(offset, \"column\");\n\n        if (offsetLine < lastOffset.line ||\n            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n          throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n        }\n        lastOffset = offset;\n\n        const cons = new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL);\n        return cons.then(consumer => {\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer\n          };\n        });\n      })).then(s => {\n        that._sections = s;\n        return that;\n      });\n    });\n  }\n\n  // `__generatedMappings` and `__originalMappings` are arrays that hold the\n  // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n  // are lazily instantiated, accessed via the `_generatedMappings` and\n  // `_originalMappings` getters respectively, and we only parse the mappings\n  // and create these arrays once queried for a source location. We jump through\n  // these hoops because there can be many thousands of mappings, and parsing\n  // them is expensive, so we only want to do it if we must.\n  //\n  // Each object in the arrays is of the form:\n  //\n  //     {\n  //       generatedLine: The line number in the generated code,\n  //       generatedColumn: The column number in the generated code,\n  //       source: The path to the original source file that generated this\n  //               chunk of code,\n  //       originalLine: The line number in the original source that\n  //                     corresponds to this chunk of generated code,\n  //       originalColumn: The column number in the original source that\n  //                       corresponds to this chunk of generated code,\n  //       name: The name of the original symbol which generated this chunk of\n  //             code.\n  //     }\n  //\n  // All properties except for `generatedLine` and `generatedColumn` can be\n  // `null`.\n  //\n  // `_generatedMappings` is ordered by the generated positions.\n  //\n  // `_originalMappings` is ordered by the original positions.\n  get _generatedMappings() {\n    if (!this.__generatedMappings) {\n      this._sortGeneratedMappings();\n    }\n\n    return this.__generatedMappings;\n  }\n\n  get _originalMappings() {\n    if (!this.__originalMappings) {\n      this._sortOriginalMappings();\n    }\n\n    return this.__originalMappings;\n  }\n\n  get _generatedMappingsUnsorted() {\n    if (!this.__generatedMappingsUnsorted) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappingsUnsorted;\n  }\n\n  get _originalMappingsUnsorted() {\n    if (!this.__originalMappingsUnsorted) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappingsUnsorted;\n  }\n\n  _sortGeneratedMappings() {\n    const mappings = this._generatedMappingsUnsorted;\n    mappings.sort(util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = mappings;\n  }\n\n  _sortOriginalMappings() {\n    const mappings = this._originalMappingsUnsorted;\n    mappings.sort(util.compareByOriginalPositions);\n    this.__originalMappings = mappings;\n  }\n\n  /**\n   * The list of original sources.\n   */\n  get sources() {\n    const sources = [];\n    for (let i = 0; i < this._sections.length; i++) {\n      for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    const sectionIndex = binarySearch.search(needle, this._sections,\n      function(aNeedle, section) {\n        const cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (aNeedle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    const section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    return this._sections.every(function(s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      const content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, \"source\")) === -1) {\n        continue;\n      }\n      const generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        const ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    const generatedMappings = this.__generatedMappingsUnsorted = [];\n    const originalMappings = this.__originalMappingsUnsorted = [];\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      const sectionMappings = [];\n      section.consumer.eachMapping(m => sectionMappings.push(m));\n\n      for (let j = 0; j < sectionMappings.length; j++) {\n        const mapping = sectionMappings[j];\n\n        // TODO: test if null is correct here.  The original code used\n        // `source`, which would actually have gotten used as null because\n        // var's get hoisted.\n        // See: https://github.com/mozilla/source-map/issues/333\n        let source = util.computeSourceURL(section.consumer.sourceRoot, null, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        let name = null;\n        if (mapping.name) {\n          this._names.add(mapping.name);\n          name = this._names.indexOf(mapping.name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        const adjustedMapping = {\n          source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name\n        };\n\n        generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === \"number\") {\n          originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    let mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    const sourceRoot = this.sourceRoot;\n    mappings.map(function(mapping) {\n      let source = null;\n      if (mapping.source !== null) {\n        source = this._sources.at(mapping.source);\n        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n      }\n      return {\n        source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  }\n\n  /**\n   * Find the mapping that best matches the hypothetical \"needle\" mapping that\n   * we are searching for in the given \"haystack\" of mappings.\n   */\n  _findMapping(aNeedle, aMappings, aLineName,\n              aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError(\"Line must be greater than or equal to 1, got \"\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError(\"Column must be greater than or equal to 0, got \"\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    const line = util.getArg(aArgs, \"line\");\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    const needle = {\n      source: util.getArg(aArgs, \"source\"),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, \"column\", 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    let index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      let mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        const originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          let lastColumn = mapping.lastGeneratedColumn;\n          if (this._computedColumnSpans && lastColumn === null) {\n            lastColumn = Infinity;\n          }\n          mappings.push({\n            line: util.getArg(mapping, \"generatedLine\", null),\n            column: util.getArg(mapping, \"generatedColumn\", null),\n            lastColumn,\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        const originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          let lastColumn = mapping.lastGeneratedColumn;\n          if (this._computedColumnSpans && lastColumn === null) {\n            lastColumn = Infinity;\n          }\n          mappings.push({\n            line: util.getArg(mapping, \"generatedLine\", null),\n            column: util.getArg(mapping, \"generatedColumn\", null),\n            lastColumn,\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  }\n\n  destroy() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.destroy();\n    }\n  }\n}\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n/*\n * Cheat to get around inter-twingled classes.  `factory()` can be at the end\n * where it has access to non-hoisted classes, but it gets hoisted itself.\n */\nfunction _factory(aSourceMap, aSourceMapURL) {\n  let sourceMap = aSourceMap;\n  if (typeof aSourceMap === \"string\") {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  const consumer = sourceMap.sections != null\n      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n  return Promise.resolve(consumer);\n}\n\nfunction _factoryBSM(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n"]}]}